"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pdfToPages = exports.pdfToText = void 0;
const pdf_js_1 = require("pdfjs-dist/build/pdf.js");
async function pdfToText(pdf, options) {
    const pages = await pdfToPages(pdf, options);
    const pageSep = getStringOptionOrDefault((options || {}).pageSep, '\n\n');
    return pages.map((page) => page.text).join(pageSep);
}
exports.pdfToText = pdfToText;
async function pdfToPages(pdf, options) {
    pdf = normalizeBuffer(pdf);
    const document = await (0, pdf_js_1.getDocument)({
        data: pdf,
        useWorkerFetch: false,
        isEvalSupported: false,
        useSystemFonts: true,
    }).promise;
    const numPages = document.numPages;
    const pages = [];
    try {
        for (let pageNum = 1; pageNum <= numPages; pageNum++) {
            const page = await document.getPage(pageNum);
            try {
                const nodeSep = getStringOptionOrDefault((options || {}).nodeSep, '\n');
                const text = await extractTextFromPage(page, nodeSep);
                pages.push({ page: pageNum, text: text });
            }
            catch (error) {
                throw error;
            }
            finally {
                page.cleanup();
            }
        }
    }
    catch (error) {
        throw error;
    }
    finally {
        document.destroy();
    }
    return pages;
}
exports.pdfToPages = pdfToPages;
async function extractTextFromPage(page, sep) {
    const content = await page.getTextContent();
    return getTextItems(content.items)
        .map((item) => item.str)
        .join(sep);
}
function getTextItems(items) {
    return items.filter((item) => typeof item.str === 'string');
}
function getStringOptionOrDefault(option, optionDefault) {
    return typeof option === 'string' ? option : optionDefault;
}
function normalizeBuffer(buffer) {
    return buffer instanceof Buffer ? new Uint8Array(buffer.buffer) : buffer;
}
//# sourceMappingURL=index.js.map