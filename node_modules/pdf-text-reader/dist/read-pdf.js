import { join } from 'node:path';
import { getDocument } from 'pdfjs-dist';
/**
 * Read a PDF and convert it into lines of text.
 *
 * If a URL is used to fetch the PDF data a standard XMLHttpRequest(XHR) is used, which means it
 * must follow the same origin rules that any XHR does e.g. No cross domain requests without CORS.
 */
export async function readPdfPages({ data, filePath, password, pathToPdfJsDistNodeModule, progressCallback, url, options, }) {
    const documentLoadingTask = getDocument({
        data,
        url: url || filePath,
        useSystemFonts: true,
        password,
        standardFontDataUrl: pathToPdfJsDistNodeModule
            ? join(pathToPdfJsDistNodeModule, 'standard_fonts')
            : undefined,
        ...options,
    });
    if (progressCallback) {
        documentLoadingTask.onProgress = progressCallback;
    }
    const document = await documentLoadingTask.promise;
    const pageCount = document.numPages;
    const pages = [];
    for (let i = 0; i < pageCount; i++) {
        const page = await document.getPage(i + 1);
        pages.push(await parsePage(page));
    }
    /** This is populated by the pdfjs-dist package. We're deleting it here to prevent memory leaks. */
    delete globalThis.pdfjsWorker;
    return pages;
}
/** Reads a PDF into a single string. */
export async function readPdfText(params) {
    const pdfPages = await readPdfPages(params);
    return combinePagesIntoSingleString(pdfPages);
}
/** Combine all PDF pages into a single string. */
export function combinePagesIntoSingleString(pages) {
    return pages
        .map((page) => page.lines)
        .flat()
        .join('\n');
}
/** Parse a single PDF page. */
export async function parsePage(pdfPage) {
    const rawContent = await pdfPage.getTextContent();
    return parsePageItems(rawContent.items.filter((item) => 'str' in item));
}
/**
 * Parses individual text items generated by pdf.js This allows lower level control of what actually
 * gets parsed. For example, a consumer of this function may remove entire sections of the pdf text
 * prior to passing items in here. See parsePage function above for example usage.
 *
 * @param pdfItems An array of TextItem items.
 */
export function parsePageItems(pdfItems) {
    const lineData = {};
    for (let i = 0; i < pdfItems.length; i++) {
        const item = pdfItems[i];
        const y = item?.transform[5];
        if (!lineData.hasOwnProperty(y)) {
            lineData[y] = [];
        }
        // how how to intentionally test this
        /* istanbul ignore next */
        if (item) {
            lineData[y]?.push(item);
        }
    }
    const yCoords = Object.keys(lineData)
        .map((key) => Number(key))
        // b - a here because the bottom is y = 0 so we want that to be last
        .sort((a, b) => b - a)
        // insert an empty line between any 2 lines where their distance is greater than the upper line's height
        .reduce((accum, currentY, index, array) => {
        const nextY = array[index + 1];
        if (nextY != undefined) {
            const currentLine = lineData[currentY];
            const currentLineHeight = currentLine.reduce((finalValue, current) => finalValue > current.height ? finalValue : current.height, -1);
            // currentY - nextY because currentY will be higher than nextY
            if (Math.floor((currentY - nextY) / currentLineHeight) > 1) {
                const newY = currentY - currentLineHeight;
                lineData[newY] = [];
                return accum.concat(currentY, newY);
            }
        }
        return accum.concat(currentY);
    }, []);
    const lines = [];
    for (let i = 0; i < yCoords.length; i++) {
        const y = yCoords[i];
        // idk how to actually test this
        /* istanbul ignore next */
        if (y == undefined) {
            continue;
        }
        // sort by x position (position in line)
        const lineItems = lineData[y].sort((a, b) => a.transform[4] - b.transform[4]).filter((item) => !!item.str);
        const firstLineItem = lineItems[0];
        let line = lineItems.length ? firstLineItem.str : '';
        for (let j = 1; j < lineItems.length; j++) {
            const item = lineItems[j];
            const lastItem = lineItems[j - 1];
            const xDiff = item.transform[4] - (lastItem.transform[4] + lastItem.width);
            // insert spaces for items that are far apart horizontally
            // idk how to trigger this
            /* istanbul ignore next */
            if (item.height !== 0 &&
                lastItem.height !== 0 &&
                (xDiff > item.height || xDiff > lastItem.height)) {
                const spaceCountA = Math.ceil(xDiff / item.height);
                let spaceCount = spaceCountA;
                if (lastItem.height !== item.height) {
                    const spaceCountB = Math.ceil(xDiff / lastItem.height);
                    spaceCount = spaceCountA > spaceCountB ? spaceCountA : spaceCountB;
                }
                line += Array(spaceCount).fill('').join(' ');
            }
            line += item.str;
        }
        lines.push(line);
    }
    return {
        lines,
    };
}
